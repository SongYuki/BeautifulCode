BeautifulCode——正则表达式匹配器

标签（空格分隔）： 未分类

---
Stephen Kleene在20世纪50年代中期发明了正则表达式，用来作为有限自动机的表示法，事实上，正则表达式与其所表示的有限自动机是等价的。

正则表达式最初出现在Ken Thompson版本的QED文本编辑器的程序设置中。1967年Thompson申请了一项基于正则表达式的快速文本匹配机制的专利。

后来，正则表达式技术从QED移植到了Unix的编辑器ed中，然后又被移植到经典的Unix工具grep中。这些广为应用的程序使得正则表达式为早期的Unix社群所熟知。

**Thompson最初编写的匹配器是非常快的，因为它结合了两种独立的思想。一种思想是在匹配过程中动态地生成机器指令，这样就可以以机器指令执行的速度而不是解释执行的速度来运行。另一种思想是在每个阶段中都尽可能地执行匹配操作，这样无需回溯backtrack就可以查找可能的匹配。**

在Thompson后来编写的文本编辑器程序中，例如ed，匹配代码使用了一种更为简单的算法，这种算法将会在必要的时候进行回溯。从理论上来看，这种方法的运行速度要更慢，但在实际情况中，这种模式很少需要进行回溯，因此，ed和grep中的算法和代码足以应付大多数的情况。

**在后来的正则表达式匹配器中，例如egrep和fgrep等，都增加了更为丰富的正则表达式类型，并且重点是要使得匹配器无论在什么模式下都能够快速执行。功能更为强大的正则表达式正在被越来越多地使用，它们不仅被包含在用C语言开发的库中，而且还被作为脚本语言如Awk&Perl的语法的一部分。**

现有的正则表达式软件包都太庞大了，grep中的代码长度超过500行，并且在代码的周围还有复杂的上下文环境。开源的正则表达式软件包则更为庞大——代码的长度几乎布满整本书——因为这些代码需要考虑通用性，灵活性以及运行速度，因此，所有这些正则表达式都不适合用来教学。

**正则表达式代码同样也是阐述算法，数据结构，测试，性能增强以及其他重要主题的最好方式**

Practical：
正则表达式匹配器，用来处理以下的模型：
c:匹配任意的字母c
.:匹配任意的单个字符
^:匹配输入字符串的开头
$:匹配输入字符串的结尾
*:匹配前一个字符的零个或者多个出现


对于正则表达式类型的扩展将形成各种任务的基础
**1.增加其他的元字符**，例如+用于表示前面字符的一个或多个出现，或者?用于表示零个或一个字符的匹配，还可以增加一些方式来引用元字符，例如\$表示在模式中的$字符
**2.将正则表达式处理过程分为编译阶段和执行阶段**。编译阶段把正则表达式转换为内部形式，使匹配代码更为简单或者使随后的匹配过程运行得更为迅速。对于最初设计中的简单正则表达式来说，这种拆分并不是必须的，但在像grep这样的程序中，这种拆分是有意义的，因为这种类型的正则表达式更为丰富，并且同样的正则表达式将会用于匹配大量的输入行。
**3.增加像[abc]和[0-9]这样的类型，这在传统的grep中分别匹配a或b或c和一个数字。**可以通过几种方式来实现，最自然的方式似乎就是把最初代码中的char*变量用一个结构来代替：
```c
typedef struct RE{
    int type;/*CHAR,STAR,etc.*/
    int ch;/*the character itself*/
    char *ccl;/*for [...] instead*/
    int nccl;/*true if class is negated[^...]*/
}RE;
```
并且修改相应的代码来处理一个结构数组而不是处理一个字符数组。在这种情况下，并不一定要把编译阶段从执行阶段中拆分出来，但这里的拆分过程是非常简单的。如果学生们把匹配代码预编译成这个结构，那么总会比那些试图动态地解释一些复杂模式数据结构的学生要做得更好。
为字符类型编写清晰并且无歧义的规范是件有难度的工作，而要用代码完美地实现处理更是难上加难，这需要大量的冗长并且晦涩的编码。随着时间的推移，现在大多数人会要求像Perl那样的速记，例如\d表示数字，\D表示非数字，而不再像最初那样在方括号内指定字符的范围。
**4.使用不透明的类型来隐藏RE结构以及所有的实现细节**.这是在C语言中展示面向对象编程技术的好方法，不过除此之外无法支持更多的东西。在实际情况中，将会创建一个正则表达式类，其中类中成员函数的名字像RE_new()和RE_match()这样，而不是使用面向对象语言的语法。
**5.把正则表达式修改为像各种shell中的通配符那样**：匹配模式的两端都被隐含地固定了，*匹配任意数量的字符，而?则匹配任意的单个字符。你可以修改这个算法或者把输入映射到现有的算法中。
**6.编写一个包装类把这种类型的正则表达式转换Java的Patter类和Matcher类，这些类将以一种与众不同的方式来拆分编译阶段和匹配阶段。**这是适配器(Adapter)模式或者外观(Facade)模式的很好示例，这两种模式用来在现有的类或者函数集合外部设置不同的接口。
**7.闭包操作*必须出现**，因为它是正则表达式中的基本记号，并且是提供处理不确定长度的唯一方式。







